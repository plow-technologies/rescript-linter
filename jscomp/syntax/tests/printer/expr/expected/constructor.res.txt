let x = true
let y = false

let r = Reducer()
let r = Reducer(state, nexState, sideEffect)
let r = Reducer(
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
)
let r = Reducer([state, nexState, sideEffect])
let r = Reducer([
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
])

let r = Reducer({state: nextState, sideEffects: []})

let c = Constr({
  firstField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  secondField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
  thirdField: superLongIdentiiiiiiiifffffffiiiiieeeeeeeer,
})

let forceBreak = Cartesian({
  x: Omega.x,
  y: Theta.y,
})

let c = Constr(list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  ...superLoooooooooooooooooooooooooooooongListHere,
})

let c = Constr(list{
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
  superLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer,
})

let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer([])
let c = ConstructorWithASuuuuuuuuuuuuuuuperLoooooooooooooooooooooooooooooongIiiiiiiiiideeeentifieeeeeeeeeeeeeeeeer(list{})

let coordinate = JsCoord({"x": 1, "y": 1})
let user = JsUser({
  "name": "steve",
  "age": 32,
})

let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      // this shouldn't break over multiple lines
      Some(node)
    } else {
      node.left->peekMinNode
    }
  }

let rec peekMinNode = node =>
  switch node {
  | None => None
  | Some(node) =>
    if node.left === None {
      // this shouldn't break over multiple lines
      MyConstructor(node, nodeLongIdentifiiiiieeeeeeer1, nodeLongIdentifiiiiieeeeeeer2)
    } else {
      node.left->peekMinNode
    }
  }

let constructor = @attr Blue

let x = switch x {
| Bar =>
  ReasonReact.UpdateWithSideEffects(
    self => {
      let _ = 1
      apply(bar)
    },
  )
| Foo => ()
}

// tuple as single argument
let x = Some((1, 2))

let math = if discriminant < 0. {
  None
} else {
  Some((
    (-.b -. Js.Math.sqrt(discriminant)) /. (2. *. a),
    (-.b +. Js.Math.sqrt(discriminant)) /. (2. *. a),
  ))
}

// hug block expressions
let first = Some({
  let uidentLoc = mkLoc(uidentStartPos, uidentEndPos)
  Ast_helper.Type.constructor(
    ~loc=mkLoc(uidentStartPos, p.prevEndPos),
    ~res?,
    ~args,
    Location.mkloc(uident, uidentLoc),
  )
})

let first = Some({
  module D = Debug
  D.log()
})

let first = Some({
  exception Exit
  raise(Exit)
})

let first = Some({
  open Debug
  log()
})

let first = Some({
  sideEffect()
  sideEffect2()
})
